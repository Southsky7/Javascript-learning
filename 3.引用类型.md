# 3.引用类型

## 3.1基本引用类型

- 引用值(或对象)是某个特定引用类型的实例，ECMAScript中，引用类型是把数据和功能组织到一起的结构，经常被错认成类，但二者不是一个概念.虽然JS是面向对象语言，但ECMAScript缺少传统的面向对象编程语言所具备的某些基本结构，比如类和接口。引用类型有时也称为对象定义，因为它们描述了自己的对象应有的属性和方法。
- 新对象通过new操作符后跟一个构造函数(constructor)创建，构造函数就是用来创建新对象的函数，如let now = new Date()

## 3.1.1 Date

- UTC:Universal Time Coordinated,自协调世界时，1970年1月1日零时

- GMT,Greenwich Mean Time，格林尼治平太阳时间，又称为UT,Universal Time，世界时。

- 不给Date传参时，创建的对象保存当前日期和时间。

- ```js
  let a = new Date();
     console.log(a);  //Thu Nov 04 2021 14:29:33 GMT+0800 (中国标准时间)
  ```

##### 3.1.1.1   Date.parse()方法，其接收一个表示日期的字符串参数，其支持的格式如下:

```js
let a = new Date(Date.parse('5/23/2019'));  //格式:月/日/年
   let b = new Date(Date.parse('May 23,2019')); //格式:月名 日，年
   let c = new Date(Date.parse('Tue May 23 2019 00:00:00 GMT-0700')); 
   let d = new Date(Date.parse('2019-05-23T00:00:00'));
   console.log(a); //Thu May 23 2019 00:00:00 GMT+0800 (中国标准时间)
   console.log(b); //abcd相同
   console.log(c);
   console.log(d);
```

- 若传给Date.parse()的字符串不表示日期则该方法返回NaN，若把日期的字符串传给Date构造函数，则Date会在后台调用Date.parse()，即let a = new Date('5/23/2019')与上面语句等效。

##### 3.1.1.2   Date.UTC()方法

- 传给Date.UTC的参数是年，零起点月数(如1月为0，2月为1)，日(1~31),时(0~23),分，秒和毫秒，只有前两个是必须的，不提供日则默认为1日，其他参数默认为0。
- Date.UTC与Date.parse()相同，会被隐式调用，但其创建的是本地日期而不是GMT日期。

```js
 let a = new Date(Date.UTC(2000,0));
   let b = new Date(Date.UTC(2005,4,5,17,55,55));
   let c = new Date(2000,0);
   let d = new Date(2005,4,5,17,55,55);
   console.log(a);   //Sat Jan 01 2000 08:00:00 GMT+0800 (中国标准时间)
   console.log(b);   //Fri May 06 2005 01:55:55 GMT+0800 (中国标准时间)
   console.log(c);   //Sat Jan 01 2000 08:00:00 GMT+0800 (中国标准时间)
   console.log(d);   //Fri May 06 2005 01:55:55 GMT+0800 (中国标准时间)
```

##### 3.1.1.3 Date.now()方法，返回方法执行是日期和时间的毫秒数，用于代码分析。

```js
 let start = Date.now();
   function sum(n){
       s = 2;
      for (i=1;i<n+1;i++){
            s = s ** i
      }
      console.log(s)
   }
   let end = Date.now();
   sum(5);
   console.log(end-start);
```

## 3.1.2 RegExp

- ECMAScript通过RegExp类型支持正则表达式，格式:let expression = /pattern/flags;

- 常见flags(匹配模式):

  - g,全局模式，表示查找字符串的全部内容而不是找到第一个就结束
  - i，不区分大小写
  - m，多行模式，表示查找到一行文本末尾时会继续查找
  - y,黏附模式，只查找从lastIndex开始及之后的字符串
  - u，Unicodem模式，启用Unicode匹配
  - s，dotAll模式，表示元字符，匹配任何字符，包括\n,\r

- 所有元字符必须使用反斜杠 \ 转义，包括(   [   {   \   ^   $   |  }   ]   )   ?   *  +  .   

- ```js
  let pattern1 = /[bc]at/i;       //匹配第一个'bat或cat'，忽略大小写
     let pattern2 = /\[bc\]at/i;  //匹配第一个'[bc]at'，忽略大小写
     let pattern3 = /.at/gi;      //匹配所有以.at结尾的三字符组合，忽略大小写
     let pattern4 = /\.at/gi;     //匹配所有'.at'，忽略大小写
  ```

- 正则表达式也可用RegExp构造函数创建，它接收两个参数:模式字符串和可选的标记字符串，两个参数都必须是字符串，所以某些情况需要二次转义，如所有元字符必须二次转义。

- RegExp也可基于已有的正则表达式实例且可选择性的修改它的标记

- ```js
     let pattern1 = /[bc]at/i;
     let pattern2 = /\[bc\]at/i;
     let a = new RegExp(pattern1);  //基于已有实例
     console.log(a);   //   /[bc]at/i
     let b = new RegExp(pattern1,'m');//修改标记  注意m必须是字符串形式
     console.log(b);   //   /[bc]at/m
  ```

- RegExp实例方法exec()，用于配合捕获组使用，此方法只接受一个参数，即要应用模式的字符串，如果找到匹配项则返回包含第一个匹配信息的数组，否则返回null，返回的数组是Array的实例，包含两个额外属性:index和input,index是字符串中匹配模式的起始位置，input是要查找的字符串。这个数组的第一个元素是匹配整个模式的字符串，其他元素是与表达式中的捕获组匹配的字符串，若模式中无捕获组，则数组只包含一个元素。

  ```js
  <script >
    let text = 'cat,bat,sat,fat';
    let pattern = /.at/g;    //若不设置g，找到第一个就会停止
    let mateches = pattern.exec(text);
    console.log(mateches.index); //0
    console.log(mateches[0]);    //cat
    console.log(pattern.lastIndex);  //3    
  </script>
  ```

- 正则表达式的另一个方法是test(),它接收一个字符串参数，若输入文本与模式匹配则返回true，否则false。它只关心是否匹配，不关心实际匹配的内容，常用于if语句

- ```js
    let text = 'cat,bat,sat,fat';
    let pattern = /.at/g;
    let mateches = pattern.exec(text);
    if(pattern.test(text)){
        console.log('The pattern was matched');  //
    }
  ```

## 3.1.3 原始值包装类型

- 为了方便操作原始值，ECMAScript提供了3种特殊的引用类型:Boolean,Number,String.每当用到原始值的方法或属性时，后台都会创建一个相应原始包装类型的对象从而暴露出操作原始值的各种方法

- ```js
  let s1 = 'ttt';
  let s2 = s1.subString(2);  //原始值本身不是对象，逻辑上不应该有方法，但是这个例子成功运行了，因为后台创建了其包装类型，对于Boolean和Number类型原始值也是一样的
  ```

- 原始值包装类型和引用类型的主要区别在于生命周期，自动创建的原始值包装对象只存在于访问它的那行代码执行期间而引用类型是在离开作用域时被销毁，这意味着不能再运行时给原始值添加属性和方法。

- 可以显式的使用Boolean、Number、String构造函数创建原始值包装类型，但应该在确实必要时这么做，否则易让开发者疑惑它们到底是原始值还是引用值，所有原始值包装类型实例调用typeof会返回object,原始值包装对象都会转换为布尔值true。

- ```js
  let obj = new Object('ttt');
    console.log(obj instanceof String); //True   Object能根据传入值的类型返回相应原始值包装类型实例
    let a = Number(25);
    console.log(typeof a);     //Number
    let b = new Number(25);  //使用new调用原始值包装类型的构造函数和调用同名的转型函数不同
    console.log(typeof b);   //Object
  ```

### 3.1.3.1 Number

- Number类型重写了valueof()、toLocalString()、toString()方法，valueof()返回原始数值，后两个返回字符串，toString()可接收参数，返回对应进制的数值字符串。

- toFixed()方法返回指定小数点位数的数值字符串.

- toExponential()方法返回科学计数法，接收一个参数表示小数的位数。

- toPrecision()方法会根据情况返回最合理的输出结果，接收一个参数表示数字总位数

- Number.isInteger()方法，用于辨别一个数值是否保存为整数。

- ```js
  let a = 56;
    console.log(a.valueOf());         //56
    console.log(a.toLocaleString());  //56
    console.log(a.toString());        //56 
    console.log(a.toString(2));       //111000
    console.log(a.toString(8));       //70
    console.log(a.toString(16));      //38
    console.log(a.toFixed(2));        //56.0
    console.log(a.toExponential(2));  //5.60e+1
    let b = 99; 
    console.log(b.toPrecision(1));    //1e+2  用1位数字表示99，将他舍入为100
    console.log(b.toPrecision(2));    //99
    console.log(b.toPrecision(3));    //99.0
    console.log(Number.isInteger(50));  //true
    console.log(Number.isInteger(50.7)); //false
  ```

### 3.1.3.2  String

- String对象的方法可以在所有字符串原始值上调用，3个继承的方法valueOf(),toLocaleString()、toString()都返回对象的原始字符串值。每个字符传都有length属性，返回字符数量。

- charAt()方法返回给定索引位置的字符。

- concat(),拼接任意多个字符串，不修改原字符串，但最常用的拼接字符串方法是加号+,更简洁。

- ECMAScript中提供了3个从字符串提取子字符串的方法:slice(),substr(),substring(),这三个方法都返回调用它们的字符串的一个字符串，且都接收1或2个参数，第一个参数表示子字符串开始的位置，第二个参数对slice()、substring()来说是提取结束的位置(左闭右开)，对substr()来说是返回的子字符串数量。任何情况下，省略第二个参数都意味着提取到字符串末尾。

- ```js
  let a = 'hello world';
    console.log(a.slice(3));   //lo world
    console.log(a.slice(-3)); //rld   slice()方法将所有负值参数当成字符串长度加上负参数值
    console.log(a.slice(3,7));// lo w
    console.log(a.slice(3,-4));  //lo w 
    console.log('-----------');
    console.log(a.substring(3)); //lo world
    console.log(a.substring(-3));//hello world  substring()将所有负值转换为0
    console.log(a.substring(3,7));//lo w
    console.log(a.substring(3,-4));//hel  
    console.log('---------')
    console.log(a.substr(3));//lo world 
    console.log(a.substr(3,7));//lo worl substr()将第二个参数当作子字符串的长度  
    console.log(a.substr(-3));// rld  substr()将第一个负参数值当成字符串长度加上该值，将第二个负参数值转换为0
    console.log(a.substr(3,-4)); // ''(空字符串)
  </script>
  ```

- #### 字符串位置方法:

  - indexOf()和lastIndexOf(),前者从开头开始查找，后者从末尾开始查找，都接收第二个参数，前者从指定位置向后查找，后者从指定位置向前查找。利用第二个参数并且循环调用函数即可找到所有目标字符串。

  - ```js
    let a = 'gagfdhgfjgffdgdgfjgfhfdjhgasdasfsgfasj';
     let positions = new Array();
     let pos = a.indexOf('a')
     while(pos>-1){
         positions.push(pos);
         pos = a.indexOf('a',pos+1);
     }
     console.log(positions);    //[1, 26, 29, 35]
    ```

- #### 字符串包含方法:

  - ES6中有3个判断一个字符串是否包含另一个字符串的方法:startWith()、endsWith()、includes()。
  - startWith()、endsWith()可接收第二个参数，表示开始搜索的位置,endsWith()接收的第二个参数表示应该当作字符串末尾的位置

- 删除字符串左右空格符trim()

  - 所有字符串都有这个方法，它会创建字符串的一个副本，删除前后所有空格符,trimLeft()和trimRight()分别用于从字符串开始和末尾清理字符串。

- repeat方法:用于重复字符串

- padStart()和padEnd()，用于复制字符串，若小于指定长度，则在相应一边填充字符串。第二个参数是可选的填充字符串，默认为空格。

- 字符串迭代for of与解构操作符[...iterable]

- ```js
   let a = '   abc   ';
   let b = 'cdf';
   console.log(a.trim());  //abc
   console.log(b.repeat(3));  //cdfcdfcdf
   console.log(b.padStart(5,'?'));  //??cdf
  let a = '   abc   ';
   let b = 'cdf';
   for (const c of b){
       console.log(c);     //c d f
   }
   console.log([...b]);   //['c', 'd', 'f']
  ```

- 字符串大小写转换:toLowerCase()、toLocaleLowerCase()、toUpperCase()、toLocaleUpperCase(),toUpperCase()和toLowerCase()是原本就有的方法，另外两个旨在基于特定地区实现，在很多地区特定的方法和通用方法是相同的，但是少数语言如土耳其语中，大小写转换有特殊规则，若不知道代码涉及什么语言，最好使用地区特定的转换方法。

- 字符串模式匹配方法:

  - match()方法，接收一个参数，可以是正则表达式字符串或RegExp对象
  - search()方法，与match()相同，但返回值是第一个匹配的位置索引，没找到返回-1
  - replace()方法，用于替换字符串，接收两个参数，第一个是RegExp对象或字符串，第二个参数可以是一个字符串或一个函数，若第一个参数是字符串那么只会替换第一个子字符串，想替换所有子字符串必须是正则表达式且带全局标记。
  - spilt(),用指定分隔符拆分字符串，作为分隔符的参数可以是字符串或RegExp对象，还可以传入第二个参数当作返回数组的大小。
  - localeCompare()方法，比较两个字符串，相等返回0，按照字母表顺序，字符串排在参数前则返回正数，反之负数。

  ```js
  let a = 'cat,pat,fat,bat';
   let pattern = /.at/;
   let matches = a.match(pattern); //等同于pattern.exec(a)
   console.log(matches.index);  
   console.log(matches[0]);
   console.log(pattern.lastIndex);
   console.log(a.search(/at/))
   
   let c = a.replace('at','ond');
   let d = a.replace(/at/g,'ond');
   console.log(c);   //cond,pat,fat,bat
   console.log(d);   //cond,pond,fond,bond   注意正则表达式不需要加引号
  
  let h = 'red,blue,dark,gray'
   console.log(h.split(','));    //['red', 'blue', 'dark', 'gray']
   console.log(h.split(',',3));  //['red', 'blue', 'dark']
  
  let word = 'tao'
  console.log(word.localeCompare('wen'));   //-1
  console.log(word.localeCompare('aw'));    //1
  console.log(word.localeCompare('tao'));   //0
  ```

  



