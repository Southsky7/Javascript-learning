# 8.期约与异步编程

- 异步和同步行为的对立统一是计算机科学的一个基本概念，特别是在JS这种单线程时间循环模型中，同步操作与异步操作是代码所依赖的核心机制。异步行为是为了优化因计算量大而时间长的操作，若在等待其他操作完成的同时，即使运行其他指令也能保持系统稳定，那么就起到了效果

- 异步操作不一定计算量大或需等很长时间，若不想为了某个异步操作而阻塞线程执行，那么任何时候都可以使用。

- setTimeout()函数,用于在指定的毫秒数后调用函数或计算表达式，setTimeout(要执行的代码，等待的毫秒数).  setTimeout(代码，毫秒数，函数)如setTimeout(console.log,0,func1)

- ```js
  let func1 = function(){
      console.log('确实帅')
  };
  setTimeout(func1,1000);//确实帅
  ```

- 回调函数callback:A callback is a function that is passed as an argument to another function and is executed after its parent function has completed，回调函数是一种被当作另一个函数的参数并且必须在它的父函数执行完成后才能执行的函数。也就是被作为参数传递到另一个函数（主函数）的那个函数就叫做回调函数。

### 1.同步和异步

- 同步行为对应内存中顺序执行的处理器指令，每条指令都会严格按照它们出现的顺序执行且每条指令执行后也能立即获得存储在系统本地(寄存器或系统内存)的信息，这样的执行流程容易分析程序在执行到任意代码位置时的状态。

- 相对的，异步行为类似系统中断，即当前进程外部的实体可触发代码执行，异步操作经常是必要的，因为强制进程等待一个长时间的操作通常不可行，若代码访问高延迟的资源，如向远程访问器发送请求且等待响应，就会出现长时间等待。异步eg:

- ```js
  let x = 3;
  setTimeout(() => x = x + 4,1000);  //此时执行线程不知道x值何时会改变，这取决于回调何时从消息队列出列且执行。异步不易推断，因为这个指令是由系统计时器触发的，这会生成一个入队执行的中断，到底什么时候触发这个中断对JS运行时来说是一个黑盒，实际上无法预知。为了让后续代码能使用x，异步函数需要在更新x的值后通知其他代码，设计一个能知道x什么时候更新的系统是有难度的。
  ```

#### 1.1以往的异步编程模式

- 早期JS只支持定义回调函数来表明异步操作完成，串联多个异步操作是常见问题，通常需要深度嵌套的回调函数(俗称回调地狱)来完成。

- ```js
  function double(value) {
      setTimeout(() => setTimeout(console.log,0,value * 2),1000)
  }
  double(3);  //6(1000ms后)  1000ms后，JS运行时会把回调函数推到自己的消息队列上去等待执行，推到队列后，回调什么时候出列被执行对JS代码来说就完全不可见了，也就是说1000ms不是它被执行需要等待的时间，而是它出列需要等待的时间，double函数在setTimeout成功调度异步操作后会立即退出。
  ```

#### 1.1.1 异步返回值

- 假设setTimeout操作返回一个有用的值，该怎样把值传到需要它的地方?通常是给异步操作提供一个回调，这个回调中包含使用异步返回值的代码(作为回调的参数)

- ```js
  function double(value,callback) {
      setTimeout(() => callback(value * 2),1000)
  }
  double(3,(x) => console.log(`i was given:${x}`)); //i was given:6
  ```

#### 1.1.2 失败处理

- 异步操作的失败处理在回调模型中也要考虑，因此出现了失败回调和成功回调

#### 1.1.3 嵌套异步回调

- 若异步返回值又依赖另一个异步返回值，那么需要嵌套回调，随着代码越来越复杂，嵌套回调的代码几乎无法维护。

## 2.期约Promise

- 期约是对尚不存在结果的一个替身，ES6新增了Promise类型，成为主导性的异步编程机制，所有现代浏览器都支持ES6期约。

#### 2.1 期约基础

- 期约通过Promise实例化，创建新期约时必须传入执行器executor函数作为参数

- ```js
  let p = new Promise(() => {});
  setTimeout(console.log,0,p);  //Promise {<pending>}
  ```

#### 2.1.1 期约状态机

- 在把一个期约实例传给console.log时，控制台输出表明该实例处于待定pengind状态。期约有3种状态:待定pending,兑现fulfilled(有时也叫解决resolved),拒绝rejected。
- pending是期约初始状态，可以落定settled为代表成功的兑现状态或代表失败的拒绝状态，无论落定为哪种状态都是不可逆的。只要从待定转换为兑现或拒绝，期约状态就不再改变，且不能保证期约必定会脱离待定状态，因此合理的代码无论期约解决还是拒绝，甚至一直待定都应该有恰当的行为。
- 期约状态是私有的，不能直接通过JS检测到，这是为了避免根据读取的期约状态以同步方式处理期约对线。且期约状态无法被外部JS代码修改，期约故意将异步行为封装，从而隔离外部的同步代码。

#### 2.1.2 解决值、拒绝利用和期约用例

- 期约有两大用途，首先是抽象的表示一个异步操作，期约的状态代表期约是否完成，某些情况下状态机就是期约可提供的最有用的信息，知道异步代码已完成就对其余代码而言足够了。
- 另外一些情况下，期约封装的异步操作实际会生成某个值，而程序期待期约状态改变时可访问这个值，若期约被拒绝，程序就会期待期约状态改变时可拿到拒绝理由。eg:假设期约向访问器发送HTTP请求且预定返回一个JSON，若请求返回范围在200~299的状态码，则期约状态变为兑现，此时期约内部就收到一个JSON字符串，若状态码不在此范围，那么就把期约状态切换为拒绝，此时拒绝理由可能是一个Error对象，包含HTTP状态码和相关错误信息。

#### 2.1.3 通过执行函数控制期约状态

- 期约状态是私有的，只能在内部操作，而内部操作在期约的执行器函数中完成，执行函数两大职责:初始化期约的异步行为和控制状态的最终转换。控制期约状态转换是通过调用它的两个函数参数resovle()和reject()实现的，前者把状态切换为兑现，后者把状态切换为拒绝且会抛出错误。

- ```js
  let p1 = new Promise((resolve,reject) => resolve());
  setTimeout(console.log,0,p1);  //Promise {<fulfilled>: undefined}
  let p2 = new Promise((resolve,reject) => reject());
  setTimeout(console.log,0,p2);  //Promise {<rejected>: undefined} Uncaught (in promise) undefined
  ```

- 为避免期约卡在待定状态，可添加一个定时退出功能，如可通过setTimeout设置一个10秒后无论如何都会拒绝期约的回调

- ```js
  let p = new Promise((resolve,reject) => setTimeout(reject,1000));//10s后调用reject
  setTimeout(console.log,0,p);  //Promise {<pending>}
  setTimeout(console.log,11000,p);//Promise {<rejected>: undefined}
  ```

#### 2.1.4 Promise.resolve()

- 期约并非一开始就必须处于待定状态，然后通过执行器函数才能转换为落定状态，通过调用Promise.resolve()静态方法可实例化一个解决的期约

- ```js
  let p1 = new Promise((resolve,reject) => resolve());
  let p2 = Promise.resolve()  //p1、p2等效
  ```

- 这个解决的期约的值对应着传给Promose.resolve()的第一个参数，使用这个静态方法实际上可以把任何值都转换为一个期约

- ```js
  setTimeout(console.log,0,Promise.resolve(0));//Promise {<fulfilled>: 0}
  setTimeout(console.log,0,Promise.resolve(3));//Promise {<fulfilled>: 3}
  setTimeout(console.log,0,Promise.resolve(5));//Promise {<fulfilled>: 5}
  ```

#### 2.1.5 Promise.reject()

- 与Promise.resolve()类似，它会实例化一个拒绝的期约并抛出一个错误，此错误不能用try/catch捕获，只能用拒绝处理程序捕获

- ```js
  let p1 = new Promise((resolve,reject) => reject());
  let p2 = Promise.reject()  //p1、p2等效
  ```

  