# 5.对象，类和面对对象编程

- ECMA-262将对象定义为一组属性的无序集合，即可以把对象想象成散列表，其中的内容就是一组键值对，值可以是数据或函数。
- ECMA-262使用一些内部特性来描述属性的特征，这些特性是由为JS实现引擎的规范定义的，因此开发者不能再JS中直接访问这些特性，为了将某个特性标识为内部特性，规范会用两个中括号把特性的名称括起来，如[[Enumberable]].

- 属性分为数据属性和访问器属性

### 1.数据属性

- 数据属性包含一个保存数据值的位置，值从这个位置读取，也会写入到这个位置，数据属性有4个特性描述它们的行为:

  - [[Configuraable]]:表示属性是否可以通过delete删除且重新定义，是否可以修改它的特性以及是否可以把它修改为访问器属性，默认为true
  - [[Enumerable]]:表示属性能否通过for-in循环返回，默认为true
  - [[Writable]]:表示属性值能否被修改，默认为true
  - [[Value]]:属性对应的值，即前面提到的读取和写入属性值的位置。

- 要修改属性的默认特性，需使用Object.defineProperty()方法，它接受3个参数:要给其添加属性的对象、属性名称、一个描述符对象。

- ```js
          let person = {};
          Object.defineProperty(person,'name',{
              writable:false,     //设置后值不可修改
              value:'雀氏帅'
          })
          console.log(person.name);   //雀氏帅
          person.name = '大帅逼';
          console.log(person.name)    //雀氏帅
  ```

- 注意一个属性的[[Configurable]]被定义为false就不能在修改回去，否则会报错

- 多数情况下不需要这些功能，只是为了深度理解JS

### 2.访问器属性

- 访问器属性不包含数据值，相反它们包含一个获取getter函数和一个设置setter函数，但这两个函数不是必须的，在读取访问器属性时，会调用获取函数，其责任是返回一个有效的值。在写入访问器属性，会调用设置函数且传入新值，这个函数需要决定对数据做出什么修改，访问器属性有4个特性描述它们的行为:

  - [[Configurable]]
  - [[Enumberable]]
  - [[Get]]:获取函数，读取属性时调用，默认为undefined
  - [[Set]]:设置函数，写入属性时调用，默认为undefined

- 访问器属性不能直接定义，必须使用Object.defineProperty()

- ```js
          let book = {
              year_ : 2017,    //year_下划线表示该属性不希望再对象方法的外部被访问
              edition:1
          };
          Object.defineProperty(book,'year',{   //访问器属性year
              get(){
                  return this.year_();
              },
              set(newValue){
                  if(newValue > 2017){
                      this.year_ = newValue;
                      this.edition += newValue-2017;
                  }
              }
          });
          book.year = 2018;
          console.log(book.edition);//2
  ```

- 获取函数和设置函数不一定都要定义，只定义获取函数表示属性只读，只定义设置函数表示属性不能读取。

### 定义多个属性

- Object.defineProperties()方法用于在一个对象上定义多个属性，它接受两个参数:要为之添加或修改属性的对象和另一个描述符对象。

```js
      let book = {};
      Object.defineProperties(book,{
          year_:{
              value:2017
          },
          edition:{
              value:1
          },
          year:{              
              get(){
                  return this.year_;
              },
              set(newValue){
                  if(newValue > 2017){
                      this.year_ = newValue;
                      this.edition += newValue-2017;
                  }
              }
          }
      })
      book.edition = 10;
      console.log(book.edition);
//这段代码定义了两个数据属性year_和edition,一个访问器属性year，其中属性属性的configurable,enumerable,writable都是false！！！！！！！！！
//通过Object.getOwnPropertyDescriptor()方法可以获取指定属性的属性描述符，其接受两个参数:属性所在对象和要取得其描述符的属性名，对于访问器属性包含configurable、enumerable、get和set，数据属性包括configurable、enumerable、writable、value'
//Object.getOwnPropertyDescriptors()方法会在每个自有属性上调Object.getOwnPropertyDescriptor()
//并在一个新对象中返回它们。
      let descriptor = Object.getOwnPropertyDescriptor(book,'year_');
      console.log(descriptor.value);  //2017
      console.log(descriptor.configurable);  //false
      console.log(descriptor.enumerable);  //false
      console.log(descriptor.writable);  ..false
      let descriptor2 = Object.getOwnPropertyDescriptor(book,'year');
      console.log(descriptor2.get);  //get函数
      console.log(descriptor2.set);//set函数
      console.log(descriptor2.configurable); //false
      console.log(descriptor2.enumerable);//fasle
```

### 合并对象

- Object.assign(目标对象，源对象)

### Object.is()

- 类似===,但考虑到了一些边界情况，如Object.is(NaN,NaN)返回true，NaN===NaN返回false

### 增强的对象语法 ！！非常重要

### 1.属性值简写

- ```js
       let name = 'tao';
       let person = {
           name:name     //由于经常有这种属性名和变量名相同的情况，为此出现了简写属性名语法
       };
       console.log(person);  //{name: "tao"}
  
       let name = 'tao';
       let person = {
           name
       };
       console.log(person); //{name: 'tao'}
  
  ```

### 2.可计算属性

- 引入可计算属性若想用变量的值作为属性，则必须先声明对象再使用中括号语法来添加属性，即不能在对象字面量中直接动态命名属性，有了可计算属性，就可以在对象字面量中完成动态属性赋值，中括号包围的对象属性键告诉运行时将其作为JS表达式而不是字符串来求值:

- ```js
  const namekey = 'name';
  const ageKey = 'age';
  const jobKey = 'job';
  
  let person = {};
  person[namekey] = 'tao';
  person[ageKey] = 22;
  person[jobKey] = 'warrior';
  console.log(person);  //{name: 'tao', age: 22, job: 'warrior'}
  
  const namekey = 'name';
  const ageKey = 'age';
  const jobKey = 'job';
  
  let person = {
      [namekey]:'tao',
      [ageKey]:'22',
      [jobKey]:'warrior'
  };
  console.log(person);   //{name: 'tao', age: '22', job: 'warrior'}
  
  ```

- 注意可计算属性中抛出任何错误都会中断对象创建，且之前完成的计算无法回滚。

### 3.简写方法名

- 给对象定义方法时放弃给函数表达式命名从而缩短方法声明。可与可计算属性兼容。

- ```js
  let person = {
      sayName:function(name){
          console.log(`My name is ${name}`);
      }
  }
  person.sayName('tao');
  //简写后
  let person = {
      sayName(name){
          console.log(`My name is ${name}`);
      }
  }
  person.sayName('tao');
  ```

## 对象结构

- 

### 