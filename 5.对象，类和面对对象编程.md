# 5.对象，类和面对对象编程

- ECMA-262将对象定义为一组属性的无序集合，即可以把对象想象成散列表，其中的内容就是一组键值对，值可以是数据或函数。
- ECMA-262使用一些内部特性来描述属性的特征，这些特性是由为JS实现引擎的规范定义的，因此开发者不能再JS中直接访问这些特性，为了将某个特性标识为内部特性，规范会用两个中括号把特性的名称括起来，如[[Enumberable]].

- 属性分为数据属性和访问器属性

### 1.数据属性

- 数据属性包含一个保存数据值的位置，值从这个位置读取，也会写入到这个位置，数据属性有4个特性描述它们的行为:

  - [[Configuraable]]:表示属性是否可以通过delete删除且重新定义，是否可以修改它的特性以及是否可以把它修改为访问器属性，默认为true
  - [[Enumerable]]:表示属性能否通过for-in循环返回，默认为true
  - [[Writable]]:表示属性值能否被修改，默认为true
  - [[Value]]:属性对应的值，即前面提到的读取和写入属性值的位置。

- 要修改属性的默认特性，需使用Object.defineProperty()方法，它接受3个参数:要给其添加属性的对象、属性名称、一个描述符对象。

- ```js
          let person = {};
          Object.defineProperty(person,'name',{
              writable:false,     //设置后值不可修改
              value:'雀氏帅'
          })
          console.log(person.name);   //雀氏帅
          person.name = '大帅逼';
          console.log(person.name)    //雀氏帅
  ```

- 注意一个属性的[[Configurable]]被定义为false就不能在修改回去，否则会报错

- 多数情况下不需要这些功能，只是为了深度理解JS

### 2.访问器属性

- 访问器属性不包含数据值，相反它们包含一个获取getter函数和一个设置setter函数，但这两个函数不是必须的，在读取访问器属性时，会调用获取函数，其责任是返回一个有效的值。在写入访问器属性，会调用设置函数且传入新值，这个函数需要决定对数据做出什么修改，访问器属性有4个特性描述它们的行为:

  - [[Configurable]]
  - [[Enumberable]]
  - [[Get]]:获取函数，读取属性时调用，默认为undefined
  - [[Set]]:设置函数，写入属性时调用，默认为undefined

- 访问器属性不能直接定义，必须使用Object.defineProperty()

- ```js
          let book = {
              year_ : 2017,    //year_下划线表示该属性不希望再对象方法的外部被访问
              edition:1
          };
          Object.defineProperty(book,'year',{   //访问器属性year
              get(){
                  return this.year_();
              },
              set(newValue){
                  if(newValue > 2017){
                      this.year_ = newValue;
                      this.edition += newValue-2017;
                  }
              }
          });
          book.year = 2018;
          console.log(book.edition);//2
  ```

- 获取函数和设置函数不一定都要定义，只定义获取函数表示属性只读，只定义设置函数表示属性不能读取。

### 定义多个属性

- Object.defineProperties()方法用于在一个对象上定义多个属性，它接受两个参数:要为之添加或修改属性的对象和另一个描述符对象。

```js
      let book = {};
      Object.defineProperties(book,{
          year_:{
              value:2017
          },
          edition:{
              value:1
          },
          year:{              
              get(){
                  return this.year_;
              },
              set(newValue){
                  if(newValue > 2017){
                      this.year_ = newValue;
                      this.edition += newValue-2017;
                  }
              }
          }
      })
      book.edition = 10;
      console.log(book.edition);
//这段代码定义了两个数据属性year_和edition,一个访问器属性year，其中属性属性的configurable,enumerable,writable都是false！！！！！！！！！
//通过Object.getOwnPropertyDescriptor()方法可以获取指定属性的属性描述符，其接受两个参数:属性所在对象和要取得其描述符的属性名，对于访问器属性包含configurable、enumerable、get和set，数据属性包括configurable、enumerable、writable、value'
//Object.getOwnPropertyDescriptors()方法会在每个自有属性上调Object.getOwnPropertyDescriptor()
//并在一个新对象中返回它们。
      let descriptor = Object.getOwnPropertyDescriptor(book,'year_');
      console.log(descriptor.value);  //2017
      console.log(descriptor.configurable);  //false
      console.log(descriptor.enumerable);  //false
      console.log(descriptor.writable);  ..false
      let descriptor2 = Object.getOwnPropertyDescriptor(book,'year');
      console.log(descriptor2.get);  //get函数
      console.log(descriptor2.set);//set函数
      console.log(descriptor2.configurable); //false
      console.log(descriptor2.enumerable);//fasle
```

### 合并对象

- Object.assign(目标对象，源对象)

### Object.is()

- 类似===,但考虑到了一些边界情况，如Object.is(NaN,NaN)返回true，NaN===NaN返回false

### 增强的对象语法 ！！非常重要

### 1.属性值简写

- ```js
       let name = 'tao';
       let person = {
           name:name     //由于经常有这种属性名和变量名相同的情况，为此出现了简写属性名语法
       };
       console.log(person);  //{name: "tao"}
    
       let name = 'tao';
       let person = {
           name
       };
       console.log(person); //{name: 'tao'}
    
  ```

### 2.可计算属性

- 引入可计算属性若想用变量的值作为属性，则必须先声明对象再使用中括号语法来添加属性，即不能在对象字面量中直接动态命名属性，有了可计算属性，就可以在对象字面量中完成动态属性赋值，中括号包围的对象属性键告诉运行时将其作为JS表达式而不是字符串来求值:

- ```js
  const namekey = 'name';
  const ageKey = 'age';
  const jobKey = 'job';
  
  let person = {};
  person[namekey] = 'tao';
  person[ageKey] = 22;
  person[jobKey] = 'warrior';
  console.log(person);  //{name: 'tao', age: 22, job: 'warrior'}
  
  const namekey = 'name';
  const ageKey = 'age';
  const jobKey = 'job';
  
  let person = {
      [namekey]:'tao',
      [ageKey]:'22',
      [jobKey]:'warrior'
  };
  console.log(person);   //{name: 'tao', age: '22', job: 'warrior'}
  
  ```

- 注意可计算属性中抛出任何错误都会中断对象创建，且之前完成的计算无法回滚。

### 3.简写方法名

- 给对象定义方法时放弃给函数表达式命名从而缩短方法声明。可与可计算属性兼容。

- ```js
  let person = {
      sayName:function(name){
          console.log(`My name is ${name}`);
      }
  }
  person.sayName('tao');
  //简写后
  let person = {
      sayName(name){
          console.log(`My name is ${name}`);
      }
  }
  person.sayName('tao');
  ```

## 对象解构

- ECMAScript6新增的语法，可在一条语句中使用嵌套数据实现一个或多个赋值操作，即使用与对象匹配的解构实现对象属性赋值。

- ```js
  //不使用解构
  let person = {
      name:'tao',
      age:25
  };
  let personName = person.name;
  let personAge  = person.age;
  //使用解构
  let person = {
      name:'tao',
      age:25
  };
  //使用解构可以在一个类似对象字面量的结构中声明多个变量同时执行多个赋值操作，若想让变量直接使用属性名称，可以使用简写语法。
  let {name:personName,age:personAge} = person;
  console.log(personName);    //tao
  console.log(personAge);     //25
  //简写语法
  let{name,age} = person;   
  console.log(name);   //tao
  console.log(age);    //25
  //若解构赋值不与对象属性匹配，则该值为undefined(不会报错，只会赋值匹配的部分)
  let{name,age,height} = person; 
  console.log(name,age,height);  //tao 25 undefined
  //赋值时也可以定义默认值，适用于不匹配的情况
  let{name,age,height=178} = person;
  console.log(name,age,height); //tao 25 178
  ```

- 解构在内部使用函数ToObject()(不能再运行时环境中直接访问)把源数据结构转换为对象，这意味着再对象结构的上下文中原始值被当成对象，也意味着null和undefined不能被解构，否则会抛出错误。

#### 嵌套解构

- 解构对于嵌套的属性或赋值目标无限制，因此可以用解构来复制对象属性。

```js
let person = {
    name:'tao',
    age:36,
    job:{
        title:'warrior'
    }
};
let personCopy = {};
({                           //解构赋值前面可以不加const/let
    name:personCopy.name,
    age:personCopy.age,
    job:personCopy.job
} = person);
console.log(personCopy);  //{name: 'tao', age: 36, job: {title: 'warrior'}}
//由于对象的引用被复制给personCopy，因此修改person.job的对象也会影响personCopy
person.job.title = 'hacker';
console.log(personCopy);  //{name: 'tao', age: 36, job: {title: 'hacker'}}
//解构赋值可以使用嵌套解构，以匹配嵌套的属性
let person = {
    name:'tao',
    age:36,
    job:{
        title:'warrior'
    }
};
let{job:{title}} = person;
console.log(title);  //warrior
//在外层属性未定义情况下不能使用嵌套解构，无论源对象还是目标对象都一样。
let person = {
    job:{
        title:'warrior'
    }
};
let personCopy = {};
({
    foo:{    //foo在源对象是Undefined
        bar:personCopy.bar
    }  
} = person)     //Uncaught TypeError: Cannot read properties of undefined (reading 'bar')
({
    job:{
        title:personCopy.job.title
    }
} = person);  //由于job在目标对象上是Undefined,因此仍然会报错。
```

### 部分解构

- 涉及多个属性的解构赋值是一个与输出无关的顺序化操作，因此若一个解构表达式涉及多个赋值，开始的赋值成功而后面的赋值出错，则整个解构赋值只会完成一部分。

```js
let person = {
    name:'tao',
    age:27
};
let personCopy = {};
({
    name:personCopy.name,
    foo:personCopy.foo,
    age:personCopy.age
} = person) ;
console.log(personCopy);   //{name: 'tao', foo: undefined, age: 27}
```

### 参数上下文匹配 ?

- 在函数参数列表也可以使用解构赋值。对参数的解构赋值不影响arguments对象，但可以在函数签名中声明字函数体内使用局部变量

- # 什么是arguments？

```js
let person = {
    name:'tao',
    age:27
};
function printPerson1(foo,{name,age},bar){
    console.log(arguments);
    console.log(name,age);
};
function printPerson2(foo,{name:personName,age:personAge},bar){
    console.log(arguments);
    console.log(personName,personAge);
};
printPerson1('1st',person,'2nd');//
printPerson1('1st',person,'2nd');
    </script>
```

## 创建对象

- 使用Object构造函数或对象字面量可以方便的创建对象，但是创建具有同样接口的多个对象需要重复 编写很多代码。

### 1.工厂模式

- 即用于抽象创建特定对象的过程

- ```js
  function creatPerson(name,age,job){
      let o = new Object();
      o.name = name;
      o.job = job;
      o.age = age;
      return o;
  }
  let person1 = creatPerson('tao',22,'warrior');
  let person2 = creatPerson('hu',22,'shopper');
  //这种工厂模式虽然解决了创建多个对象的问题，但没有解决对象标识问题(即新创建的对象是什么类型)
  ```

### 2.构造函数模式

- 