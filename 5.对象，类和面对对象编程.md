# 5.对象，类和面对对象编程

- ECMA-262将对象定义为一组属性的无序集合，即可以把对象想象成散列表，其中的内容就是一组键值对，值可以是数据或函数。
- ECMA-262使用一些内部特性来描述属性的特征，这些特性是由为JS实现引擎的规范定义的，因此开发者不能再JS中直接访问这些特性，为了将某个特性标识为内部特性，规范会用两个中括号把特性的名称括起来，如[[Enumberable]].

- 属性分为数据属性和访问器属性

### 1.数据属性

- 数据属性包含一个保存数据值的位置，值从这个位置读取，也会写入到这个位置，数据属性有4个特性描述它们的行为:

  - [[Configuraable]]:表示属性是否可以通过delete删除且重新定义，是否可以修改它的特性以及是否可以把它修改为访问器属性，默认为true
  - [[Enumerable]]:表示属性能否通过for-in循环返回，默认为true
  - [[Writable]]:表示属性值能否被修改，默认为true
  - [[Value]]:属性对应的值，即前面提到的读取和写入属性值的位置。

- 要修改属性的默认特性，需使用Object.defineProperty()方法，它接受3个参数:要给其添加属性的对象、属性名称、一个描述符对象。

- ```js
          let person = {};
          Object.defineProperty(person,'name',{
              writable:false,     //设置后值不可修改
              value:'雀氏帅'
          })
          console.log(person.name);   //雀氏帅
          person.name = '大帅逼';
          console.log(person.name)    //雀氏帅
  ```

- 注意一个属性的[[Configurable]]被定义为false就不能在修改回去，否则会报错

- 多数情况下不需要这些功能，只是为了深度理解JS

### 2.访问器属性

- 访问器属性不包含数据值，相反它们包含一个获取getter函数和一个设置setter函数，但这两个函数不是必须的，在读取访问器属性时，会调用获取函数，其责任是返回一个有效的值。在写入访问器属性，会调用设置函数且传入新值，这个函数需要决定对数据做出什么修改，访问器属性有4个特性描述它们的行为:

  - [[Configurable]]
  - [[Enumberable]]
  - [[Get]]:获取函数，读取属性时调用，默认为undefined
  - [[Set]]:设置函数，写入属性时调用，默认为undefined

- 访问器属性不能直接定义，必须使用Object.defineProperty()

- ```js
          let book = {
              year_ : 2017,    //year_下划线表示该属性不希望再对象方法的外部被访问
              edition:1
          };
          Object.defineProperty(book,'year',{   //访问器属性year
              get(){
                  return this.year_();
              },
              set(newValue){
                  if(newValue > 2017){
                      this.year_ = newValue;
                      this.edition += newValue-2017;
                  }
              }
          });
          book.year = 2018;
          console.log(book.edition);//2
  ```

- 获取函数和设置函数不一定都要定义，只定义获取函数表示属性只读，只定义设置函数表示属性不能读取。

### 定义多个属性

- Object.defineProperties()方法用于在一个对象上定义多个属性，它接受两个参数:要为之添加或修改属性的对象和另一个描述符对象。

```js
      let book = {};
      Object.defineProperties(book,{
          year_:{
              value:2017
          },
          edition:{
              value:1
          },
          year:{              
              get(){
                  return this.year_;
              },
              set(newValue){
                  if(newValue > 2017){
                      this.year_ = newValue;
                      this.edition += newValue-2017;
                  }
              }
          }
      })
      book.edition = 10;
      console.log(book.edition);
//这段代码定义了两个数据属性year_和edition,一个访问器属性year，其中属性属性的configurable,enumerable,writable都是false！！！！！！！！！
//通过Object.getOwnPropertyDescriptor()方法可以获取指定属性的属性描述符，其接受两个参数:属性所在对象和要取得其描述符的属性名，对于访问器属性包含configurable、enumerable、get和set，数据属性包括configurable、enumerable、writable、value'
//Object.getOwnPropertyDescriptors()方法会在每个自有属性上调Object.getOwnPropertyDescriptor()
//并在一个新对象中返回它们。
      let descriptor = Object.getOwnPropertyDescriptor(book,'year_');
      console.log(descriptor.value);  //2017
      console.log(descriptor.configurable);  //false
      console.log(descriptor.enumerable);  //false
      console.log(descriptor.writable);  ..false
      let descriptor2 = Object.getOwnPropertyDescriptor(book,'year');
      console.log(descriptor2.get);  //get函数
      console.log(descriptor2.set);//set函数
      console.log(descriptor2.configurable); //false
      console.log(descriptor2.enumerable);//fasle
```

### 合并对象

- Object.assign(目标对象，源对象)

### Object.is()

- 类似===,但考虑到了一些边界情况，如Object.is(NaN,NaN)返回true，NaN===NaN返回false

### 增强的对象语法 ！！非常重要

### 1.属性值简写

- ```js
       let name = 'tao';
       let person = {
           name:name     //由于经常有这种属性名和变量名相同的情况，为此出现了简写属性名语法
       };
       console.log(person);  //{name: "tao"}
    
       let name = 'tao';
       let person = {
           name
       };
       console.log(person); //{name: 'tao'}
    
  ```

### 2.可计算属性

- 引入可计算属性若想用变量的值作为属性，则必须先声明对象再使用中括号语法来添加属性，即不能在对象字面量中直接动态命名属性，有了可计算属性，就可以在对象字面量中完成动态属性赋值，中括号包围的对象属性键告诉运行时将其作为JS表达式而不是字符串来求值:

- ```js
  const namekey = 'name';
  const ageKey = 'age';
  const jobKey = 'job';
  
  let person = {};
  person[namekey] = 'tao';
  person[ageKey] = 22;
  person[jobKey] = 'warrior';
  console.log(person);  //{name: 'tao', age: 22, job: 'warrior'}
  
  const namekey = 'name';
  const ageKey = 'age';
  const jobKey = 'job';
  
  let person = {
      [namekey]:'tao',
      [ageKey]:'22',
      [jobKey]:'warrior'
  };
  console.log(person);   //{name: 'tao', age: '22', job: 'warrior'}
  
  ```

- 注意可计算属性中抛出任何错误都会中断对象创建，且之前完成的计算无法回滚。

### 3.简写方法名

- 给对象定义方法时放弃给函数表达式命名从而缩短方法声明。可与可计算属性兼容。

- ```js
  let person = {
      sayName:function(name){
          console.log(`My name is ${name}`);
      }
  }
  person.sayName('tao');
  //简写后
  let person = {
      sayName(name){
          console.log(`My name is ${name}`);
      }
  }
  person.sayName('tao');
  ```

## 对象解构

- ECMAScript6新增的语法，可在一条语句中使用嵌套数据实现一个或多个赋值操作，即使用与对象匹配的解构实现对象属性赋值。

- ```js
  //不使用解构
  let person = {
      name:'tao',
      age:25
  };
  let personName = person.name;
  let personAge  = person.age;
  //使用解构
  let person = {
      name:'tao',
      age:25
  };
  //使用解构可以在一个类似对象字面量的结构中声明多个变量同时执行多个赋值操作，若想让变量直接使用属性名称，可以使用简写语法。
  let {name:personName,age:personAge} = person;
  console.log(personName);    //tao
  console.log(personAge);     //25
  //简写语法
  let{name,age} = person;   
  console.log(name);   //tao
  console.log(age);    //25
  //若解构赋值不与对象属性匹配，则该值为undefined(不会报错，只会赋值匹配的部分)
  let{name,age,height} = person; 
  console.log(name,age,height);  //tao 25 undefined
  //赋值时也可以定义默认值，适用于不匹配的情况
  let{name,age,height=178} = person;
  console.log(name,age,height); //tao 25 178
  ```

- 解构在内部使用函数ToObject()(不能再运行时环境中直接访问)把源数据结构转换为对象，这意味着再对象结构的上下文中原始值被当成对象，也意味着null和undefined不能被解构，否则会抛出错误。

#### 嵌套解构

- 解构对于嵌套的属性或赋值目标无限制，因此可以用解构来复制对象属性。

```js
let person = {
    name:'tao',
    age:36,
    job:{
        title:'warrior'
    }
};
let personCopy = {};
({                           //解构赋值前面可以不加const/let
    name:personCopy.name,
    age:personCopy.age,
    job:personCopy.job
} = person);
console.log(personCopy);  //{name: 'tao', age: 36, job: {title: 'warrior'}}
//由于对象的引用被复制给personCopy，因此修改person.job的对象也会影响personCopy
person.job.title = 'hacker';
console.log(personCopy);  //{name: 'tao', age: 36, job: {title: 'hacker'}}
//解构赋值可以使用嵌套解构，以匹配嵌套的属性
let person = {
    name:'tao',
    age:36,
    job:{
        title:'warrior'
    }
};
let{job:{title}} = person;
console.log(title);  //warrior
//在外层属性未定义情况下不能使用嵌套解构，无论源对象还是目标对象都一样。
let person = {
    job:{
        title:'warrior'
    }
};
let personCopy = {};
({
    foo:{    //foo在源对象是Undefined
        bar:personCopy.bar
    }  
} = person)     //Uncaught TypeError: Cannot read properties of undefined (reading 'bar')
({
    job:{
        title:personCopy.job.title
    }
} = person);  //由于job在目标对象上是Undefined,因此仍然会报错。
```

### 部分解构

- 涉及多个属性的解构赋值是一个与输出无关的顺序化操作，因此若一个解构表达式涉及多个赋值，开始的赋值成功而后面的赋值出错，则整个解构赋值只会完成一部分。

```js
let person = {
    name:'tao',
    age:27
};
let personCopy = {};
({
    name:personCopy.name,
    foo:personCopy.foo,
    age:personCopy.age
} = person) ;
console.log(personCopy);   //{name: 'tao', foo: undefined, age: 27}
```

### 参数上下文匹配 ?

- 在函数参数列表也可以使用解构赋值。对参数的解构赋值不影响arguments对象，但可以在函数签名中声明字函数体内使用局部变量

- # 什么是arguments？

```js
let person = {
    name:'tao',
    age:27
};
function printPerson1(foo,{name,age},bar){
    console.log(arguments);
    console.log(name,age);
};
function printPerson2(foo,{name:personName,age:personAge},bar){
    console.log(arguments);
    console.log(personName,personAge);
};
printPerson1('1st',person,'2nd');//
printPerson1('1st',person,'2nd');
    </script>
```

## 创建对象

- 使用Object构造函数或对象字面量可以方便的创建对象，但是创建具有同样接口的多个对象需要重复 编写很多代码。

### 1.工厂模式

- 即用于抽象创建特定对象的过程

- ```js
  function creatPerson(name,age,job){
      let o = new Object();
      o.name = name;
      o.job = job;
      o.age = age;
      return o;
  }
  let person1 = creatPerson('tao',22,'warrior');
  let person2 = creatPerson('hu',22,'shopper');
  //这种工厂模式虽然解决了创建多个对象的问题，但没有解决对象标识问题(即新创建的对象是什么类型)
  ```

### 2.构造函数模式

- ECMAScript中的构造函数是用于创建特定类型对象的，像Object和Array这样的原生构造函数运行时可以直接使用。也可以自定义构造函数，以函数的形式为自己的对象类型定义属性和方法。

- ```js
  function Person(name,age,job){   //按照惯例，构造函数首字母大写
      this.name = name;
      this.age = age;
      this.job = job;
  };
  let person1 = new Person('tao',25,'warrior');
  let person2 = new Person('wen',22,'Sekrio');
  //person1和person2分别保存着Person的不同实例，这两个对象都有一个constructor属性指向Person.
      function Person(name,age,job){
          this.name = name;
          this.age = age;
          this.job = job;
      };
      let person1 = new Person('tao',25,'warrior');
      let person2 = new Person('wen',22,'Sekrio');
      console.log(person1.constructor == Person);  //true
      console.log(person2.constructor == Person);  //true
  //constructor本来是用于标识对象类型的，但通常认为instanceof操作符是确定对象类型更可靠的方式，person1、person1既是Person的实例也是Object的实例。
  //构造函数也可以写成赋值表达式的形式:
      let Person = function(name,age,job){
          this.name = name;
          this.age = age;
          this.job = job;
      };
  //实例化时若不传参则构造函数后的括号可加可不加
      let Person = function(name,age,job){
          this.name = name;
          this.age = age;
          this.job = job;
      };
      let person1 = new Person;
      let person2 = new Person();
  ```

- Person()和creatPerson()区别:

  - 没有显示的创建对象
  - 属性和方法赋给了this
  - 无return

- 构造函数也是函数，唯一区别是调用方式不同，任何函数只要使用new 操作符调用就是构造函数，不使用new操作符调用就是普通函数。

- ```js
  //作为普通函数调用
  Person('tao',25,'warrior');  //添加到window对象
  window.sayName();  //tao
  //在另一个对象的作用域中调用
  let o = new Object();
  Person.call(o,'tao','nurse');
  o.sayName();    //tao
  ```

### 构造函数的问题

- 主要在于其定义的方法会在每个实例上都创建一遍，如person1和person2都有名为sayName()的方法，但这两个方法不是一个Function实例，因为都是做一样的事情因此没必要定义两个不同的Function实例，且this对象可以把对函数与对象的绑定延迟到运行时。为了解决这个问题，可以把函数定义移到构造函数外部。

- ```js
      let Person = function(name,age,job){
          this.name = name;
          this.age = age;
          this.job = job;
          this.sayName = sayName;
      };
      function sayName(){
          console.log(this.name);
      }
  ```

- 此时person1和person2共享了定义在全局作用域上的sayName()函数。这样虽然解决了相同逻辑的函数重复定义问题，但全局作用域也被搞乱了，因为那个函数实际只能在一个对象上调用，若对象需要多个方法，就要在全局作用域定义多个函数，导致自定义类型引用的代码无法很好的聚集在一起，这个问题可以通过原型模式解决。

# 原型模式

- 每个函数都会创建一个prototype属性，这个属性是一个对象，包含应该由特定引用类型的实例共享的属性和方法，实际上这个对象就是调用构造函数创建的对象的原型。使用原型对象的好处是在它上面定义的属性和方法可以被对象实例共享，原本在构造函数中直接赋给对象实例的值可以直接赋值给它们的原型。

- ```js
  function Person(){}
  Person.prototype.name = 'tao';
  Person.prototype.age = 25;
  Person.prototype.job = 'warrior';
  Person.prototype.sayName = function(){
      console.log(this.name);
  }
  let person1 = new Person();
  person1.sayName();  //tao
  let person2 = new Person();
  person2.sayName();  //tao
  console.log(person1.sayName == person2.sayName);  //true
  //此时所有属性和sayName()方法都被直接添加到了Person的prototype属性上，构造函数体中是空的，与构造模式不同，原型模式定义的属性和方法是由所有实例共享的，因此person1和person2访问的是相同的sayName()函数
  ```

### 理解原型

- 无论何时主要创建一个函数，就会按特定规则为此函数创建一个prototype属性，默认情况下所有原型对象自动获得一个叫constructor的属性，指回与之关联的构造函数，如Person.prototype.constructor指向Person，然后因构造函数而异，可能给原型对象添加其他属性和方法。

- 自定义构造函数时，原型对象默认只获得constructor属性，其他所有方法继承自Object，每次调用构造函数创建一个新实例，这个实例内部[[Prototype]]指针就会被赋值为构造函数的原型对象，脚本中没有直接访问这个[[Prototype]]特性的标准方式，但Firefox、Safari、Chrome会在每个对象上暴露__ proto __属性，通过这个属性可以访问对象的原型，其他实现中这个特性被完全隐藏了，关键在于理解:实例和构造函数原型有直接联系，实例和构造函数没有。

- ```js
  function Person(){}//声明后，构造函数就有了与之关联的原型对象
  console.log(Person.prototype);  //{constructor: ƒ Person()}
  console.log(typeof Person.prototype);//object
  //原型也有了constructor属性引用构造函数，二者循环引用
  console.log(Person.prototype.constructor === Person); //true
  //正常的原型链都会终止于Object的原型对象，Object原型的原型是null
  console.log(Person.prototype.__proto__ === Object.prototype); //true
  console.log(Person.prototype.__proto__.constructor===Object); //true
  console.log(Person.prototype.__proto__.__proto__ === null);   //true
  //实例通过__proto__链接到原型对象，它实际指向隐藏特性[[Prototype]]
  //实例和构造函数无直接联系，与原型对象有
  console.log(person1.__proto__ == Person.prototype);  //true
  //虽然不是所有实现都有__ proto __方法，但可以通过isPrototypeOf()方法确定两个对象之间的对象。
  console.log(Person.prototype.isPrototypeOf(person1));    //true
  //ECMAScript的Object类型的Object.getPrototypeOf()方法返回参数的内部特性[[Prototype]]的值，如
  console.log(Object.getPrototypeOf(person1) === Person.prototype); //true
  //使用Object,getPrototypeOf()可以取得一个对象原型，这在通过原型实现继承时非常重要。
  ```

  ![image-20211115155115246](http://r19kczb6x.hn-bkt.clouddn.com/img/image-20211115155115246.png)

### 原型层级

- 通过对象访问属性时，会按照属性名称开始搜索，先搜索实例本身，若没找到再搜索原型，最后返回对应值，这就是原型再多个对象实例共享属性和方法的原理，如前面提到的constructor属性只存在于原型对象，但通过实例对象也可以访问，因为当实例上没找到时会去搜索它的原型。
- 通过实例无法修改原型对象上的值，但是可以通过在实例上添加同名属性从而遮蔽(shadow)原型对象的属性，即屏蔽对它的访问，添加同名属性后即使把这个属性设置为null，依旧会屏蔽原型对象，但是可以通过delete操作符完全删除实例上的属性，从而可以访问到原型对象上的属性

- ```js
  function Person(){
      Person.prototype.name = 'tao';
  }
  let person1 = new Person();
  let person2 = new Person();
  person1.name = 'wen';
  console.log(person1.name);   //wen  实现了屏蔽效果
  console.log(person2.name);   //tao  来自原型
  console.log(person1.name);  //tao  解除屏蔽
  
  //hasOwnProperty()方法用于确定某个属性是在实例还是原型对象上，当存在于实例返回true，反之false。
  function Person(){
      Person.prototype.name = 'tao';
  }
  let person1 = new Person();
  let person2 = new Person();
  person1.name = 'wen';
  console.log(person1.hasOwnProperty('name'));  //true person1的name来自实例
  console.log(person2.hasOwnProperty('name'));  //false
  ```

  ### 原型和in操作符

- 使用in操作符有两种方式:单独使用和for-in循环，单独使用时in操作符会在可通过对象访问指定属性时返回true，无论在实例还是原型上，若要确定属性是否存在于原型上，则可以配合hasOwnProperty()使用。

- ```js
  function Person(){
      Person.prototype.name = 'tao';
  }
  let person1 = new Person();
  let person2 = new Person();
  person1.name = 'wen';
  console.log('name' in person1); //true
  //检测属性是否存在于原型
  function hasPrototypeProperty(object,name){
      return !object.hasOwnProperty(name) &&(name in object);
  }
  console.log(hasPrototypeProperty(person1,'name')); //false
  console.log(hasPrototypeProperty(person2,'name')); //true
  ```

- 在for-in循环中使用in操作符时，可通过对象访问且可以被枚举的属性都会返回，包括实例和原型属性，遮蔽原型中不可枚举([[Enumerable]]特性为false)属性的实例属性也会在for-in循环返回，因为默认情况下开发者定义的属性都是可以枚举的。

- 要获取对象上所有可枚举的实例属性可用Object.keys()方法，它接受一个对象作为参数，返回该对象所有可枚举属性名称的字符串数组。

- ```js
  function Person(){}
      Person.prototype.name = 'tao';
      Person.prototype.age = 29;
      Person.prototype.job = 'warrior';
  let keys = Object.keys(Person.prototype);
  console.log(keys);       //['name', 'age', 'job']
  let person1 = new Person;
  person1.name = 'dddd';
  person1.age = 50;
  let p1keys = Object.keys(person1);
  console.log(p1keys);    //['name', 'age'] 
  //若想列出所有实例属性，无论是否可枚举，可使用Object.getOwnPropertyName():
  let keys3 = Object.getOwnPropertyNames(Person.prototype);
  console.log(keys3);  //['constructor', 'name', 'age', 'job']  这里的constructor是不可枚举的
  ```

- Object.keys()和Object.getOwnPropertyNames()在适当时候都可以用于替代for-in.

- ECMAScript6新增符号类型后，相应的增加了一个Object.getOwnPropertyNames()的兄弟方法Object.getOwnPropertySymbols(),因为以符号为键的属性没有名称的概念，这个方法只针对符号。

- ```js
  let k1 = Symbol('k1'),
      k2 = Symbol('k2');
  let o = {
      [k1]:'k1',
      [k2]:'k2'
  }
  console.log(Object.getOwnPropertySymbols(o));  //[Symbol(k1), Symbol(k2)]
  ```

  